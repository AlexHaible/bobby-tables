# Header entry was created by KBabel!
#
# Lars Dɪᴇᴄᴋᴏᴡ 迪拉斯 <daxim@cpan.org>, 2010, 2012.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: 2012-03-11 23:04+0100\n"
"Last-Translator: Lars Dɪᴇᴄᴋᴏᴡ <daxim@cpan.org>\n"
"Language-Team: German <>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.2\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#: crank.pl:30
msgid "Home"
msgstr "Übersicht"

#~ msgid ""
#~ "C\\#\n"
#~ "==="
#~ msgstr ""
#~ "C\\#\n"
#~ "==="

#~ msgid ""
#~ "ColdFusion\n"
#~ "=========="
#~ msgstr ""
#~ "ColdFusion\n"
#~ "=========="

#~ msgid "or"
#~ msgstr "oder"

#~ msgid ""
#~ "Note that the query must be in single-quotes or have the `$` escaped\n"
#~ "to avoid PHP trying to parse it as a variable."
#~ msgstr ""
#~ "Hinweis: die Abfrage muss in einfachen Anführungszeichen stehen oder das `"
#~ "$` muss maskiert werden, damit PHP nicht versucht, es als Variable zu "
#~ "analysieren."

#~ msgid ""
#~ "Thanks\n"
#~ "======"
#~ msgstr ""
#~ "Danksagung\n"
#~ "=========="

#~ msgid ""
#~ "In ColdFusion there is a tag called `cfqueryparam` that should be used "
#~ "whenever writing inline queries."
#~ msgstr ""
#~ "In ColdFusion gibt es eine Funktion `cfqueryparam`, die immer benutzt "
#~ "werden sollte, um eingebettete Abfragen zu schreiben."

#~ msgid ""
#~ "CHICKEN Scheme\n"
#~ "--------------"
#~ msgstr ""
#~ "CHICKEN-Scheme\n"
#~ "--------------"

#~ msgid ""
#~ "Using mysqli\n"
#~ "------------"
#~ msgstr ""
#~ "Mittels mysqli\n"
#~ "--------------"

#~ msgid ""
#~ "    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
#~ "\",\n"
#~ "        SqlDbType.VarChar, 25 /* max length of field */ );"
#~ msgstr ""
#~ "    SqlParameter userNameParam = userInfoQuery.Parameters.Add(\"@UserName"
#~ "\",\n"
#~ "        SqlDbType.VarChar, 25 /* max length of field */ );"

#~ msgid ""
#~ "    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = "
#~ "$1', array($email) );"
#~ msgstr ""
#~ "    $result = pg_query_params( $dbh, 'SELECT * FROM users WHERE email = "
#~ "$1', array($email) );"

#~ msgid "Fork me on GitHub"
#~ msgstr "Mach auf GitHub mit"

#~ msgid ""
#~ "\n"
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
#~ "30));"
#~ msgstr ""
#~ "\n"
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
#~ "30));"

#~ msgid "**Mom**: Oh. Yes. Little Bobby Tables we call him."
#~ msgstr "**Mutter**: Oh. Ja. Wir rufen ihn Klein Bobby Tables."

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname TEXT\n"
#~ "    ) RETURNS timestamp language plpgsql AS $$\n"
#~ "    BEGIN\n"
#~ "        RETURN accessed_at FROM users WHERE username = p_uname;\n"
#~ "    END;\n"
#~ "    $$;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname TEXT\n"
#~ "    ) RETURNS timestamp language plpgsql AS $$\n"
#~ "    BEGIN\n"
#~ "        RETURN accessed_at FROM users WHERE username = p_uname;\n"
#~ "    END;\n"
#~ "    $$;"

#~ msgid "To use a prepared statement, do something like this:"
#~ msgstr "Um eine vorbereitete Anweisung zu benutzen:"

#~ msgid ""
#~ "From the [C# Online](http://en.csharp-online.net/) wiki page [ASP.NET "
#~ "Security Hacks--Avoiding SQL Injection](http://en.csharp-online.net/ASP."
#~ "NET_Security_Hacks%E2%80%94Avoiding_SQL_Injection)"
#~ msgstr ""
#~ "[ASP.NET Security Hacks — Avoiding SQL Injection](http://en.csharp-online."
#~ "net/ASP.NET_Security_Hacks%E2%80%Avoiding_SQL_Injection) aus dem [C#-"
#~ "Online-Wiki](http://en.csharp-online.net/)"

#~ msgid ""
#~ "        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
#~ "          PIPE ROW(v_users(i));\n"
#~ "        END LOOP;"
#~ msgstr ""
#~ "        FOR i IN v_users.FIRST .. v_users.LAST LOOP\n"
#~ "          PIPE ROW(v_users(i));\n"
#~ "        END LOOP;"

#~ msgid "Or simpler:"
#~ msgstr "Oder einfacher:"

#~ msgid ""
#~ "    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email "
#~ "= ?' );\n"
#~ "    $success = odbc_execute( $stmt, array($email) );"
#~ msgstr ""
#~ "    $stmt = odbc_prepare( $conn, 'SELECT * FROM users WHERE email "
#~ "= ?' );\n"
#~ "    $success = odbc_execute( $stmt, array($email) );"

#~ msgid ""
#~ "\n"
#~ "    SqlCommand userInfoQuery = new SqlCommand(\n"
#~ "        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
#~ "        someSqlConnection);"
#~ msgstr ""
#~ "\n"
#~ "    SqlCommand userInfoQuery = new SqlCommand(\n"
#~ "        \"SELECT id, name, email FROM users WHERE id = @UserName\",\n"
#~ "        someSqlConnection);"

#~ msgid ""
#~ "    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
#~ "    /"
#~ msgstr ""
#~ "    CREATE OR REPLACE TYPE userlist_t AS TABLE OF VARCHAR2(8);\n"
#~ "    /"

#~ msgid ""
#~ "    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
#~ "    $stmt->bind_param('si',$name,$id);\n"
#~ "    $stmt->execute();"
#~ msgstr ""
#~ "    $stmt = $db->prepare('update people set name = ? where id = ?');\n"
#~ "    $stmt->bind_param('si',$name,$id);\n"
#~ "    $stmt->execute();"

#~ msgid ""
#~ "Using the [Python DB API](http://wiki.python.org/moin/"
#~ "DatabaseProgramming/), don't do this:"
#~ msgstr ""
#~ "Unter Verwendung der [Python-DB-API](http://wiki.python.org/moin/"
#~ "DatabaseProgramming/) ist das folgende falsch:"

#~ msgid ""
#~ "Recent versions of ColdFusion provide a set of functions to run queries "
#~ "that\n"
#~ "have a slightly different syntax, but still provide parameterized queries."
#~ msgstr ""
#~ "Neuere Versionen von ColdFusion haben Funktionen,\n"
#~ "um Abfragen mit einer leicht veränderten Syntax durchzuführen,\n"
#~ "die aber dennoch parameterisierte Abfragen haben."

#~ msgid ""
#~ "    $dbConnection = NewADOConnection($connectionString);\n"
#~ "    $sqlResult = $dbConnection->Execute(\n"
#~ "        'SELECT user_id,first_name,last_name FROM users WHERE username=? "
#~ "AND password=?',\n"
#~ "        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
#~ "    );"
#~ msgstr ""
#~ "    $dbConnection = NewADOConnection($connectionString);\n"
#~ "    $sqlResult = $dbConnection->Execute(\n"
#~ "        'SELECT user_id,first_name,last_name FROM users WHERE username=? "
#~ "AND password=?',\n"
#~ "        array($_REQUEST['username'], sha1($_REQUEST['password'])\n"
#~ "    );"

#~ msgid ""
#~ "-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953."
#~ "aspx) on MSDN\n"
#~ "-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
#~ "archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) on the ASP.NET "
#~ "Debugging blog"
#~ msgstr ""
#~ "-   [SQL injection](http://msdn.microsoft.com/en-us/library/ms161953."
#~ "aspx) auf MSDN\n"
#~ "-   [SQL Injection and how to avoid it](http://blogs.msdn.com/tom/"
#~ "archive/2008/05/29/sql-injection-and-how-to-avoid-it.aspx) auf dem Blog "
#~ "\"ASP.NET Debugging\""

#~ msgid ""
#~ "\n"
#~ "    SELECT user_access('janihur')\n"
#~ "      AS \"JANIHUR LAST SEEN\" FROM DUAL;"
#~ msgstr ""
#~ "\n"
#~ "    SELECT user_access('janihur')\n"
#~ "      AS \"JANIHUR LAST SEEN\" FROM DUAL;"

#~ msgid ""
#~ "Who is Bobby Tables?\n"
#~ "===================="
#~ msgstr ""
#~ "Wer ist Bobby Tables?\n"
#~ "====================="

#~ msgid ""
#~ "Implicit Data Type Conversion Injection\n"
#~ "---------------------------------------"
#~ msgstr ""
#~ "Einschleusung durch implizite Datentypumwandlung\n"
#~ "------------------------------------------------"

#~ msgid ""
#~ "<a href=\"http://xkcd.com/327/\"><img src=\"img/xkcd.png\" alt=\"xkcd "
#~ "Bobby Tables Cartoon\" height=\"205\" width=\"666\" /></a>"
#~ msgstr ""
#~ "<a href=\"http://xkcd.com/327/\"><img src=\"../img/xkcd.png\" alt=\"xkcd-"
#~ "Comic &quot;Bobby Tables&quot;\" height=\"205\" width=\"666\" /></a>"

#~ msgid ""
#~ "PL/pgSQL\n"
#~ "--------"
#~ msgstr ""
#~ "PL/pgSQL\n"
#~ "--------"

#~ msgid ""
#~ "**School**: Hi, this is your son's school. We're having some computer "
#~ "trouble."
#~ msgstr ""
#~ "**Schule**: Hallo, hier spricht die Schule Ihres Sohnes. Wir haben "
#~ "Computerprobleme."

#~ msgid "TODO.\n"
#~ msgstr "In Vorbereitung.\n"

#~ msgid ""
#~ "**School**: In a way. Did you really name your son `Robert'); DROP TABLE "
#~ "Students;--`?"
#~ msgstr ""
#~ "**Schule**: So ähnlich. Haben sie Ihren Sohn wirklich `Robert'); DROP "
#~ "TABLE Students;--` genannt?"

#~ msgid ""
#~ "    SELECT user_access('whocares'' or superuser = 1 or username = "
#~ "''whocares') \n"
#~ "      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"
#~ msgstr ""
#~ "    SELECT user_access('whocares'' or superuser = 1 or username = "
#~ "''whocares') \n"
#~ "      AS \"SUPERUSER LAST SEEN\" FROM DUAL;"

#~ msgid ""
#~ "**School**: Well, we've lost this year's student records. I hope you're "
#~ "happy."
#~ msgstr ""
#~ "**Schule**: Also, der Datenbestand der Schüler dieses Jahres ist futsch. "
#~ "Ich hoffe, Sie sind jetzt glücklich."

#~ msgid "bobby-tables.com: A guide to preventing SQL injection"
#~ msgstr "bobby-tables.com: Ein Leitfaden gegen SQL-Einschleusung"

#~ msgid ""
#~ "\n"
#~ "How to avoid Bobby Tables\n"
#~ "========================="
#~ msgstr ""
#~ "\n"
#~ "Wie man Bobby Tables vermeidet\n"
#~ "=============================="

#~ msgid ""
#~ "    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, "
#~ "$password);\n"
#~ "    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
#~ "id');\n"
#~ "    $stmt->execute( array('new_name' => $name, 'id' => $id) );\n"
#~ msgstr ""
#~ "    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, "
#~ "$password);\n"
#~ "    $stmt = $dbh->prepare('UPDATE people SET name = :new_name WHERE id = :"
#~ "id');\n"
#~ "    $stmt->execute( array('new_name' => $name, 'id' => $id) );\n"

#~ msgid ""
#~ "* Do not create SQL statements that include outside data.\n"
#~ "* Use parameterized SQL calls."
#~ msgstr ""
#~ "* indem man keine SQL-Anweisungen erstellt, die von außen kommende Daten "
#~ "enthalten.\n"
#~ "* indem man SQL-Aufrufe mit Parametern tätigt."

#~ msgid "Static SQL leaves no room for SQL injection."
#~ msgstr "Statisches SQL kann keine SQL-Einschleusung verursachen."

#~ msgid ""
#~ "The strip gets one thing crucially wrong. The answer is not to \"sanitize "
#~ "your database inputs\" yourself. It is prone to error."
#~ msgstr ""
#~ "Im Comic wird eine Sache falsch gemacht. Die Antwort lautet nicht, die "
#~ "Datenbankeingaben selber zu bereinigen. Dies ist fehleranfällig."

#~ msgid "Instead use bind variables:"
#~ msgstr "Man benutzt stattdessen Bindevariablen:"

#~ msgid "See the sidebar to the left for your specific language."
#~ msgstr "Siehe Kasten links für die jeweilige Sprache."

#~ msgid ""
#~ "    public interface PeopleMapper {\n"
#~ "        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
#~ "name, @Param(\"age\") int age);\n"
#~ "    }"
#~ msgstr ""
#~ "    public interface PeopleMapper {\n"
#~ "        List<Person> selectPeopleByNameAndAge(@Param(\"lastName\") String "
#~ "name, @Param(\"age\") int age);\n"
#~ "    }"

#~ msgid ""
#~ "* [SQL Injection Myths and Fallacies](http://www.slideshare.net/"
#~ "billkarwin/sql-injection-myths-and-fallacies)\n"
#~ "* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
#~ "archives/2008/10/how_to_write_in.html)\n"
#~ "* [Defending Against SQL Injection Attacks](http://download.oracle.com/"
#~ "oll/tutorials/SQLInjection/index.htm)"
#~ msgstr ""
#~ "* [SQL Injection Myths and Fallacies](http://www.slideshare.net/"
#~ "billkarwin/sql-injection-myths-and-fallacies)\n"
#~ "* [How to Write Injection-Proof SQL](http://www.schneier.com/blog/"
#~ "archives/2008/10/how_to_write_in.html)\n"
#~ "* [Defending Against SQL Injection Attacks](http://download.oracle.com/"
#~ "oll/tutorials/SQLInjection/index.htm)"

#~ msgid ""
#~ "The remedy is to set the format modifier explicitly: `to_char(p_since, "
#~ "'YYYY-MM-DD')`."
#~ msgstr ""
#~ "Abhilfe schafft, den Formatwandler explizit anzugeben: `to_char(p_since, "
#~ "'YYYY-MM-DD')`."

#~ msgid ""
#~ "Don't see a language that you'd like to see represented? Please let me "
#~ "know if you have updates or additions through one of these methods, in "
#~ "decreasing order of preference."
#~ msgstr ""
#~ "Wird eine Sprache vermisst? Bitte melde Verbesserungen oder Ergänzungen "
#~ "auf eine dieser drei Arten, in absteigender Reihenfolge der Bevorzugung."

#~ msgid ""
#~ "PostgreSQL\n"
#~ "=========="
#~ msgstr ""
#~ "PostgreSQL\n"
#~ "=========="

#~ msgid ""
#~ "Translations also welcome\n"
#~ "========================="
#~ msgstr ""
#~ "Übersetzungen sind auch willkommen\n"
#~ "=================================="

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION get_users(\n"
#~ "        p_column TEXT,\n"
#~ "        p_value  TEXT\n"
#~ "    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
#~ "    DECLARE\n"
#~ "        query TEXT := 'SELECT * FROM users';\n"
#~ "    BEGIN\n"
#~ "        IF p_column IS NOT NULL THEN\n"
#~ "            query := query || ' WHERE ' || quote_ident(p_column)\n"
#~ "                  || ' = ' || quote_literal(p_value);\n"
#~ "        END IF;\n"
#~ "        RETURN QUERY EXECUTE query;\n"
#~ "    END;\n"
#~ "    $$;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION get_users(\n"
#~ "        p_column TEXT,\n"
#~ "        p_value  TEXT\n"
#~ "    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
#~ "    DECLARE\n"
#~ "        query TEXT := 'SELECT * FROM users';\n"
#~ "    BEGIN\n"
#~ "        IF p_column IS NOT NULL THEN\n"
#~ "            query := query || ' WHERE ' || quote_ident(p_column)\n"
#~ "                  || ' = ' || quote_literal(p_value);\n"
#~ "        END IF;\n"
#~ "        RETURN QUERY EXECUTE query;\n"
#~ "    END;\n"
#~ "    $$;"

#~ msgid ""
#~ "See the instructions at the [bobby-tables repository at github](http://"
#~ "github.com/petdance/bobby-tables#readme)."
#~ msgstr ""
#~ "Siehe Anleitung im [Repository bobby-tables auf github](http://github.com/"
#~ "petdance/bobby-tables#readme)."

#~ msgid ""
#~ "PL/Perl\n"
#~ "-------"
#~ msgstr ""
#~ "PL/Perl\n"
#~ "-------"

#~ msgid ""
#~ "* Explain why creating code from outside data is bad.\n"
#~ "* Potential speed win when reusing prepared statements."
#~ msgstr ""
#~ "* Erklärung, warum es schlecht ist, Anweisung auf Grundlage von außerhalb "
#~ "kommender Daten zu erzeugen.\n"
#~ "* Möglicher Geschwindigkeitszuwachs unter Wiederverwendung vorbereiteter "
#~ "Anweisungen."

#~ msgid ""
#~ "\n"
#~ "Stored procedures can be invoked with the `cfstoredproc` and "
#~ "`cfprocparam` tags."
#~ msgstr ""
#~ "\n"
#~ "Wenn man gespeicherte Prozeduren in der Datenbank hat, kann man sie mit "
#~ "den Funktionen `cfstoredproc` und `cfprocparam` aufrufen."

#~ msgid "Thanks to the following folks for their contributions:"
#~ msgstr "Dank gilt den folgenden Leuten für ihre Mitwirkung:"

#~ msgid ""
#~ "\n"
#~ "    (define DB (sqlite3:open  \"myexample.db\"))\n"
#~ "    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke "
#~ "Skywalker\")\n"
#~ "    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?"
#~ "\" 3)\n"
#~ "    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE "
#~ "age >= ?\" 18))"
#~ msgstr ""
#~ "\n"
#~ "    (define DB (sqlite3:open  \"myexample.db\"))\n"
#~ "    (sqlite3:exec DB \"INSERT INTO Person(name) VALUES(?)\" \"Luke "
#~ "Skywalker\")\n"
#~ "    (sqlite3:for-each-row print DB \"SELECT id,name FROM Person WHERE id=?"
#~ "\" 3)\n"
#~ "    (define adults (sqlite3:map-row DB \"SELECT name FROM Person WHERE "
#~ "age >= ?\" 18))"

#~ msgid ""
#~ "Java\n"
#~ "===="
#~ msgstr ""
#~ "Java\n"
#~ "===="

#~ msgid ""
#~ "Using ADODB\n"
#~ "-----------"
#~ msgstr ""
#~ "Mittels ADODB\n"
#~ "-------------"

#~ msgid ""
#~ "The [JDBC API](http://download.oracle.com/javase/tutorial/jdbc/index."
#~ "html)\n"
#~ "has a class called\n"
#~ "[`PreparedStatement`](http://download.oracle.com/javase/6/docs/api/java/"
#~ "sql/PreparedStatement.html)\n"
#~ "which allows the programmer to safely insert user-supplied data\n"
#~ "into a SQL query.  The location of each input value in the query\n"
#~ "string is marked with a question mark.  The various `set*()` methods\n"
#~ "are then used to safely perform the insertion."
#~ msgstr ""
#~ "Die [JDBC-API](http://download.oracle.com/javase/tutorial/jdbc/index."
#~ "html)\n"
#~ "enthält eine Klasse [`PreparedStatement`](http://download.oracle.com/"
#~ "javase/6/docs/api/java/sql/PreparedStatement.html), die Benutzereingaben "
#~ "sicher in eine SQL-Abfrage einfügt.\n"
#~ "Der Ort jedes Eingabewerts im Abfragestring ist durch ein Fragezeichen\n"
#~ "markiert. Die diversen Methoden `set*()` werden dann benutzt, um sicher\n"
#~ "einzufügen."

#~ msgid ""
#~ "    <cfquery name=\"queryTest\">\n"
#~ "    SELECT FirstName, LastName, Phone\n"
#~ "    FROM   tblUser\n"
#~ "    WHERE  Status =\n"
#~ "      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#"
#~ "\">\n"
#~ "    </cfquery>"
#~ msgstr ""
#~ "    <cfquery name=\"queryTest\">\n"
#~ "    SELECT FirstName, LastName, Phone\n"
#~ "    FROM   tblUser\n"
#~ "    WHERE  Status =\n"
#~ "      <cfqueryparam cfsqltype=\"CF_SQL_VARCHAR\" value=\"#form.status#"
#~ "\">\n"
#~ "    </cfquery>"

#~ msgid ""
#~ "\n"
#~ "Once a `PreparedStatement` object has been created, it can be reused\n"
#~ "multiple times for multiple queries (for example, when using the\n"
#~ "same query to update multiple rows in a table).  However, they are\n"
#~ "**not thread-safe** because of the many method calls involved in\n"
#~ "setting the parameters and executing the query.  Therefore, you\n"
#~ "should only define `PreparedStatement` objects as method-level\n"
#~ "variables (as opposed to class-level variables) to avoid concurrency\n"
#~ "issues."
#~ msgstr ""
#~ "\n"
#~ "Nachdem ein Objekt vom Typ `PreparedStatement` erzeugt wurde, kann es\n"
#~ "mehrfach für Abfragen wiederverwendet werden (z.B. wenn dieselbe Abfrage\n"
#~ "mehrere Zeilen in einer Tabelle aktualisiert). Aber sie sind wegen der\n"
#~ " vielen Methodenaufrufe, die die Parameter setzen und die Abfrage\n"
#~ "ausführen, **nicht threadsicher**. Deswegen sollte man Objekte vom Typ\n"
#~ "`PreparedStatement` nur als methodensichtbare Variablen (im Gegensatz\n"
#~ "zu klassensichtbaren Variablen) definieren, um Nebenläufigkeitsprobleme\n"
#~ "zu vermeiden."

#~ msgid "Here's the long way to do bind parameters."
#~ msgstr "So bindet man Parameter auf die ausführliche Weise."

#~ msgid ""
#~ "More information on `PreparedStatement` can be found in the\n"
#~ "[Oracle JDBC tutorial](http://download.oracle.com/javase/tutorial/jdbc/"
#~ "basics/prepared.html)."
#~ msgstr ""
#~ "Weitere Informationen über `PreparedStatement` sind in der\n"
#~ "[Oracle-JDBC-Anleitung](http://download.oracle.com/javase/tutorial/jdbc/"
#~ "basics/prepared.html)\n"
#~ "zu finden."

#~ msgid ""
#~ "    // insert one row\n"
#~ "    $name = 'one';\n"
#~ "    $value = 1;\n"
#~ "    $stmt->execute();"
#~ msgstr ""
#~ "    // eine Zeile einfügen\n"
#~ "    $name = 'one';\n"
#~ "    $value = 1;\n"
#~ "    $stmt->execute();"

#~ msgid ""
#~ "[Hibernate](http://www.hibernate.org/) uses named parameters to\n"
#~ "safely insert data into a query.  A named parameter consists of a\n"
#~ "colon, followed by a unique name for the parameter."
#~ msgstr ""
#~ "[Hibernate](http://www.hibernate.org/) benutzt benannte Parameter,\n"
#~ "um Daten sicher in eine Abfrage einzufügen. Ein benannter Parameter\n"
#~ "besteht aus einem Doppelpunkt gefolgt von einem eindeutigen Namen\n"
#~ "für den Parameter."

#~ msgid ""
#~ "    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
#~ "    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
#~ "    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
#~ "    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"
#~ msgstr ""
#~ "    INSERT INTO users VALUES ('janihur',  sysdate,      0);\n"
#~ "    INSERT INTO users VALUES ('petdance', sysdate - 12, 1);\n"
#~ "    INSERT INTO users VALUES ('albundy',  sysdate - 3,  0);\n"
#~ "    INSERT INTO users VALUES ('donduck',  sysdate - 18, 0);"

#~ msgid ""
#~ "Hibernate also supports positional parameters like `PreparedStatement`,\n"
#~ "but named parameters are generally preferred because they make the\n"
#~ "query a little easier to read."
#~ msgstr ""
#~ "Hibernate unterstützt auch Stellenparameter wie in `PreparedStatement`,\n"
#~ "aber benannte Parameter werden gewöhnlich bevorzugt, weil die Abfrage\n"
#~ "damit ein bisschen leichter zu lesen ist."

#~ msgid "Examples assume the following table structure:"
#~ msgstr "Beispiele setzen folgende Tabellenstruktur voraus:"

#~ msgid ""
#~ "MyBatis\n"
#~ "-------"
#~ msgstr ""
#~ "MyBatis\n"
#~ "-------"

#~ msgid ""
#~ "\n"
#~ "If you need dynamic SQL avoid string concatenation when possible\n"
#~ "----------------------------------------------------------------"
#~ msgstr ""
#~ "\n"
#~ "Wenn dynamisches SQL benötigt wird, soll wenn möglich Stringverknüpfung "
#~ "vermieden werden\n"
#~ "----------------------------------------------------------------------------------------"

#~ msgid ""
#~ "MyBatis automatically creates `PreparedStatement`s behind the scenes.\n"
#~ "Nothing extra needs to be done by the programmer."
#~ msgstr ""
#~ "MyBatis erstellt automatisch `PreparedStatement` hinter den Kulissen.\n"
#~ "Der Programmierer braucht nichts weiter zu machen."

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT accessed_at FROM users WHERE username = ''' || p_uname "
#~ "|| '''';\n"
#~ "    BEGIN\n"
#~ "        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT accessed_at FROM users WHERE username = ''' || p_uname "
#~ "|| '''';\n"
#~ "    BEGIN\n"
#~ "        EXECUTE IMMEDIATE v_query INTO v_accessed_at;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"

#~ msgid ""
#~ "XML mapping document\n"
#~ "===================="
#~ msgstr ""
#~ "XML-Zuordnungsdatei\n"
#~ "==================="

#~ msgid ""
#~ "In next example data type conversion takes place when `p_since` is "
#~ "implicitly converted to a string for concatenation. Note how the value of "
#~ "`NLS_DATE_FORMAT` affects to the query string in `users_since()` function!"
#~ msgstr ""
#~ "Im nächsten Beispiel findet Datentypumwandlung statt, wenn `p_since` "
#~ "implizit in einen String für die Verknüpfung umgewandelt wird. Achtung: "
#~ "der Wert von `NLS_DATE_FORMAT` beeinflusst den Abfragestring in der "
#~ "Funktion `users_since()`!"

#~ msgid ""
#~ "Mapper class\n"
#~ "============"
#~ msgstr ""
#~ "Zuordnungsklasse\n"
#~ "================"

#~ msgid ""
#~ "PHP is a little more disorganized than how\n"
#~ "[Perl handles parameters](./perl.html).\n"
#~ "The standard [MySQL extension](http://php.net/manual/en/book.mysql.php)\n"
#~ "doesn't support parameterization, although the\n"
#~ "[PostgreSQL extension](http://www.php.net/manual/en/book.pgsql.php) does:"
#~ msgstr ""
#~ "PHP ist ein bisschen unorganisierter im [Vergleich zu Perl](./perl."
#~ "html).\n"
#~ "Die Standarderweiterung [MySQL](http://php.net/manual/de/book.mysql.php)\n"
#~ "beherrscht keine Parameterisierung, aber die Erweiterung\n"
#~ "[PostgreSQL](http://www.php.net/manual/de/book.pgsql.php) schon:"

#~ msgid ""
#~ "Invoking the query\n"
#~ "=================="
#~ msgstr ""
#~ "Aufruf der Abfrage\n"
#~ "=================="

#~ msgid ""
#~ "    REGULARS\n"
#~ "    --------\n"
#~ "    janihur\n"
#~ "    albundy\n"
#~ "    donduck"
#~ msgstr ""
#~ "    REGULARS\n"
#~ "    --------\n"
#~ "    janihur\n"
#~ "    albundy\n"
#~ "    donduck"

#~ msgid ""
#~ "Perl\n"
#~ "===="
#~ msgstr ""
#~ "Perl\n"
#~ "===="

#~ msgid ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at > ''\n"
#~ "    or superuser = 1 or username = 'whocares' order by accessed_at desc"
#~ msgstr ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at > ''\n"
#~ "    or superuser = 1 or username = 'whocares' order by accessed_at desc"

#~ msgid ""
#~ "\n"
#~ "    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
#~ "    foreach my $email (@emails) {\n"
#~ "        $sth->execute($email);\n"
#~ "        $row = $sth->fetchrow_hashref;\n"
#~ "        [...]\n"
#~ "    }"
#~ msgstr ""
#~ "\n"
#~ "    $sth = $dbh->prepare(\"SELECT * FROM users WHERE email = ?\");\n"
#~ "    foreach my $email (@emails) {\n"
#~ "        $sth->execute($email);\n"
#~ "        $row = $sth->fetchrow_hashref;\n"
#~ "        [...]\n"
#~ "    }"

#~ msgid ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at >\n"
#~ "    '2011-07-04' order by accessed_at desc"
#~ msgstr ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at >\n"
#~ "    '2011-07-04' order by accessed_at desc"

#~ msgid ""
#~ "    # Make sure a table name we want to use is safe:\n"
#~ "    my $quoted_table_name = $dbh->quote_identifier($table_name);"
#~ msgstr ""
#~ "    # Dafür sorgen, dass der zu verwendende Tabellenname sicher ist:\n"
#~ "    my $quoted_table_name = $dbh->quote_identifier($table_name);"

#~ msgid ""
#~ "Now the value of NLS parameter `NLS_DATE_FORMAT` is ignored during the "
#~ "query."
#~ msgstr ""
#~ "Jetzt wird der Wert des NLS-Parameters `NLS_DATE_FORMAT` während der "
#~ "Abfrage nicht mehr beachtet."

#~ msgid ""
#~ "    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"
#~ msgstr ""
#~ "    my $sth = $dbh->prepare(\"SELECT $cols FROM $quoted_table_name ...\");"

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname TEXT\n"
#~ "    ) RETURNS timestamp language sql AS $$\n"
#~ "        SELECT accessed_at FROM users WHERE username = $1;\n"
#~ "    $$;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname TEXT\n"
#~ "    ) RETURNS timestamp language sql AS $$\n"
#~ "        SELECT accessed_at FROM users WHERE username = $1;\n"
#~ "    $$;"

#~ msgid ""
#~ "What is Taint mode?\n"
#~ "-------------------"
#~ msgstr ""
#~ "Was ist der Taint-Modus?\n"
#~ "------------------------"

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION get_users(\n"
#~ "        p_column TEXT,\n"
#~ "        p_value  TEXT\n"
#~ "    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
#~ "    DECLARE\n"
#~ "        query TEXT := 'SELECT * FROM users';\n"
#~ "    BEGIN\n"
#~ "        IF p_column IS NOT NULL THEN\n"
#~ "            query := query || ' WHERE ' || p_column\n"
#~ "                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
#~ "        END IF;\n"
#~ "        RETURN QUERY EXECUTE query;\n"
#~ "    END;\n"
#~ "    $$;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION get_users(\n"
#~ "        p_column TEXT,\n"
#~ "        p_value  TEXT\n"
#~ "    ) RETURNS SETOF users LANGUAGE plpgsql AS $$\n"
#~ "    DECLARE\n"
#~ "        query TEXT := 'SELECT * FROM users';\n"
#~ "    BEGIN\n"
#~ "        IF p_column IS NOT NULL THEN\n"
#~ "            query := query || ' WHERE ' || p_column\n"
#~ "                  || $_$ = '$_$ || p_value || $_$'$_$;\n"
#~ "        END IF;\n"
#~ "        RETURN QUERY EXECUTE query;\n"
#~ "    END;\n"
#~ "    $$;"

#~ msgid "To invoke taint mode:"
#~ msgstr "Um den Taintmodus anzuschalten:"

#~ msgid ""
#~ "PL/Python\n"
#~ "---------"
#~ msgstr ""
#~ "PL/Python\n"
#~ "---------"

#~ msgid ""
#~ "    # At the top of your script\n"
#~ "    #!/usr/bin/perl -T"
#~ msgstr ""
#~ "    # Am Anfang des Skripts\n"
#~ "    #!/usr/bin/perl -T"

#~ msgid ""
#~ "When your script trips one of the taint checks your application will "
#~ "issue a fatal error message. For testing purposes `-t` will issue "
#~ "warnings instead of fatal errors. `-t` is not a substitute for `-T`."
#~ msgstr ""
#~ "Wenn eine Taintprüfung im Skript fehlschlägt, gibt die Anwendung eine "
#~ "fatale Fehlermeldung aus. Für Testzwecke gibt `-t` Warnungen statt "
#~ "fataler Fehler aus. `-t` ist kein Ersatz für `-T`."

#~ msgid "Explain how DBI supports taint mode, both inbound and outbound.\n"
#~ msgstr ""
#~ "Erklärung zum Taintmodus von Perl und wie DBI den Taintmodus sowohl "
#~ "einwärts als auch ausgehend unterstützt.\n"

#~ msgid ""
#~ "PHP\n"
#~ "==="
#~ msgstr ""
#~ "PHP\n"
#~ "==="

#~ msgid ""
#~ "In Ruby on Rails using [ActiveRecord](http://guides.rubyonrails.org/"
#~ "active_record_querying.html):"
#~ msgstr ""
#~ "In Ruby on Rails mit [ActiveRecord](http://guides.rubyonrails.org/"
#~ "active_record_querying.html):"

#~ msgid ""
#~ "    objCmd.CommandType = adCmdText;\n"
#~ "    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
#~ "memberID = @memberID\";\n"
#~ "    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
#~ "adInteger, adParamInput, 4, memberid ));\n"
#~ "    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
#~ "adVarChar, adParamInput, 510, fileName));\n"
#~ "    objCmd.Execute(adExecuteNoRecords);\n"
#~ "    gblDelobjParams(objCmd);"
#~ msgstr ""
#~ "    objCmd.CommandType = adCmdText;\n"
#~ "    objCmd.CommandText = \"UPDATE members SET photo = @filename WHERE "
#~ "memberID = @memberID\";\n"
#~ "    objCmd.Parameters.Append(objCmd.CreateParameter(\"@memberID\", "
#~ "adInteger, adParamInput, 4, memberid ));\n"
#~ "    objCmd.Parameters.Append(objCmd.CreateParameter(\"@filename\", "
#~ "adVarChar, adParamInput, 510, fileName));\n"
#~ "    objCmd.Execute(adExecuteNoRecords);\n"
#~ "    gblDelobjParams(objCmd);"

#~ msgid "Reference:"
#~ msgstr "Literaturhinweis:"

#~ msgid ""
#~ "Delphi\n"
#~ "======"
#~ msgstr ""
#~ "Delphi\n"
#~ "======"

#~ msgid ""
#~ "\n"
#~ "Using [Ruby/DBI](http://ruby-dbi.rubyforge.org/): analog to [Perl](./perl."
#~ "html)."
#~ msgstr ""
#~ "\n"
#~ "[Ruby/DBI](http://ruby-dbi.rubyforge.org/) ist analog zu [Perl](./perl."
#~ "html)."

#~ msgid ""
#~ "Other random resources\n"
#~ "======================"
#~ msgstr ""
#~ "Andere wahllose Ressourcen\n"
#~ "=========================="

#~ msgid ""
#~ "* Kirk Kimmel\n"
#~ "* Nathan Mahdavi\n"
#~ "* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
#~ "hofmann-hannes)\n"
#~ "* [Mike Angstadt](http://www.mangst.com)\n"
#~ "* [Peter Ward](http://identi.ca/flowblok/)\n"
#~ "* [David Wheeler](http://justatheory.com)\n"
#~ "* Scott Rose\n"
#~ "* Erik Osheim\n"
#~ "* Russ Sivak\n"
#~ "* [Iain Collins](http://iaincollins.com)\n"
#~ "* Kristoffer Sall Hansen\n"
#~ "* Jeff Emminger\n"
#~ "* [Travis Swicegood](http://www.travisswicegood.com/)\n"
#~ "* [Will Coleda](http://www.coleda.com/users/coke/)\n"
#~ "* Kai Baesler\n"
#~ "* Mike Markley\n"
#~ "* [Michael Schwern](http://schwern.dreamhosters.com/)\n"
#~ "* [Jeana Clark](http://jeanaclark.org/)\n"
#~ "* [Lars Dɪᴇᴄᴋᴏᴡ](http://search.cpan.org/~daxim/)\n"
#~ "* [Jani Hur](http://www.jani-hur.net)\n"
#~ msgstr ""
#~ "* Kirk Kimmel\n"
#~ "* Nathan Mahdavi\n"
#~ "* [Hannes Hofmann](http://www5.informatik.uni-erlangen.de/en/our-team/"
#~ "hofmann-hannes)\n"
#~ "* [Mike Angstadt](http://www.mangst.com)\n"
#~ "* [Peter Ward](http://identi.ca/flowblok/)\n"
#~ "* [David Wheeler](http://justatheory.com)\n"
#~ "* Scott Rose\n"
#~ "* Erik Osheim\n"
#~ "* Russ Sivak\n"
#~ "* [Iain Collins](http://iaincollins.com)\n"
#~ "* Kristoffer Sall Hansen\n"
#~ "* Jeff Emminger\n"
#~ "* [Travis Swicegood](http://www.travisswicegood.com/)\n"
#~ "* [Will Coleda](http://www.coleda.com/users/coke/)\n"
#~ "* Kai Baesler\n"
#~ "* Mike Markley\n"
#~ "* [Michael Schwern](http://schwern.dreamhosters.com/)\n"
#~ "* [Jeana Clark](http://jeanaclark.org/)\n"
#~ "* [Lars Dɪᴇᴄᴋᴏᴡ](http://search.cpan.org/~daxim/)\n"
#~ "* [Jani Hur](http://www.jani-hur.net)\n"

#~ msgid ""
#~ "ADODB provides a way to prepare, bind and execute all in the same method "
#~ "call."
#~ msgstr ""
#~ "Mit ADODB kann man in einem Methodenaufruf eine Anweisung vorbereiten, "
#~ "daran binden und sie ausführen."

#~ msgid ""
#~ "    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
#~ "    query.Prepare;\n"
#~ "    query.ParamByName( 'Name' ).AsString := name;\n"
#~ "    query.ParamByName( 'ID' ).AsInteger := id;\n"
#~ "    query.ExecSQL;\n"
#~ msgstr ""
#~ "    query.SQL.Text := 'update people set name=:Name where id=:ID';\n"
#~ "    query.Prepare;\n"
#~ "    query.ParamByName( 'Name' ).AsString := name;\n"
#~ "    query.ParamByName( 'ID' ).AsInteger := id;\n"
#~ "    query.ExecSQL;\n"

#~ msgid ""
#~ "Using the ODBC layer\n"
#~ "--------------------"
#~ msgstr ""
#~ "Mittels ODBC\n"
#~ "------------"

#~ msgid ""
#~ "JDBC\n"
#~ "----"
#~ msgstr ""
#~ "JDBC\n"
#~ "----"

#~ msgid "Or:"
#~ msgstr "Oder:"

#~ msgid ""
#~ "    // userName is some string valued user input variable\n"
#~ "    userNameParam.Value = userName;"
#~ msgstr ""
#~ "    // userName ist eine vom Benutzer eingegebene Stringvariable\n"
#~ "    userNameParam.Value = userName;"

#~ msgid ""
#~ "Using the PDO layer\n"
#~ "-------------------"
#~ msgstr ""
#~ "Mittels PDO\n"
#~ "-----------"

#~ msgid "Add some narrative\n"
#~ msgstr "Mehr Erläuterung\n"

#~ msgid ""
#~ "    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, "
#~ "$password);\n"
#~ "    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
#~ "name, :value)');\n"
#~ "    $stmt->bindParam(':name', $name);\n"
#~ "    $stmt->bindParam(':value', $value);"
#~ msgstr ""
#~ "    $dbh = new PDO('mysql:dbname=testdb;host=127.0.0.1', $user, "
#~ "$password);\n"
#~ "    $stmt = $dbh->prepare('INSERT INTO REGISTRY (name, value) VALUES (:"
#~ "name, :value)');\n"
#~ "    $stmt->bindParam(':name', $name);\n"
#~ "    $stmt->bindParam(':value', $value);"

#~ msgid "Articles:"
#~ msgstr "Artikel:"

#~ msgid "And a shorter way to pass things in."
#~ msgstr "Und auf eine kürzere Weise, sie zu übergeben."

#~ msgid ""
#~ "    List<Person>; people = //user input\n"
#~ "    Connection connection = DriverManager.getConnection(...);\n"
#~ "    connection.setAutoCommit(false);\n"
#~ "    try {\n"
#~ "        PreparedStatement statement = connection.prepareStatement(\n"
#~ "                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?"
#~ "\");\n"
#~ "        for (Person person : people){\n"
#~ "            statement.setString(1, person.getLastName());\n"
#~ "            statement.setInt(2, person.getAge());\n"
#~ "            statement.setInt(3, person.getId());\n"
#~ "            statement.execute();\n"
#~ "        }\n"
#~ "        connection.commit();\n"
#~ "    } catch (SQLException e) {\n"
#~ "        connection.rollback();\n"
#~ "    }"
#~ msgstr ""
#~ "    List<Person>; people = //Benutzereingabe\n"
#~ "    Connection connection = DriverManager.getConnection(...);\n"
#~ "    connection.setAutoCommit(false);\n"
#~ "    try {\n"
#~ "        PreparedStatement statement = connection.prepareStatement(\n"
#~ "                \"UPDATE people SET lastName = ?, age = ? WHERE id = ?"
#~ "\");\n"
#~ "        for (Person person : people){\n"
#~ "            statement.setString(1, person.getLastName());\n"
#~ "            statement.setInt(2, person.getAge());\n"
#~ "            statement.setInt(3, person.getId());\n"
#~ "            statement.execute();\n"
#~ "        }\n"
#~ "        connection.commit();\n"
#~ "    } catch (SQLException e) {\n"
#~ "        connection.rollback();\n"
#~ "    }"

#~ msgid ""
#~ "PL/SQL\n"
#~ "======"
#~ msgstr ""
#~ "PL/SQL\n"
#~ "======"

#~ msgid "**Mom**: And I hope you've learned to sanitize your database inputs."
#~ msgstr ""
#~ "**Mutter**: Und ich hoffe, Sie haben gelernt, Datenbankeingaben zu "
#~ "bereinigen."

#~ msgid ""
#~ "    CREATE TABLE users (\n"
#~ "        username VARCHAR2(8) UNIQUE,\n"
#~ "        accessed_at DATE,\n"
#~ "        superuser NUMBER(1,0)\n"
#~ "    );"
#~ msgstr ""
#~ "    CREATE TABLE users (\n"
#~ "        username VARCHAR2(8) UNIQUE,\n"
#~ "        accessed_at DATE,\n"
#~ "        superuser NUMBER(1,0)\n"
#~ "    );"

#~ msgid "There is only one way to avoid Bobby Tables attacks"
#~ msgstr "Man kann Bobby-Tables-Angriffe nur vermeiden,"

#~ msgid ""
#~ "Always prefer static SQL when possible\n"
#~ "--------------------------------------"
#~ msgstr ""
#~ "Wenn möglich, immer statisches SQL bevorzugen\n"
#~ "---------------------------------------------"

#~ msgid ""
#~ "Hibernate\n"
#~ "---------"
#~ msgstr ""
#~ "Hibernate\n"
#~ "---------"

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "    BEGIN\n"
#~ "        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
#~ "p_uname;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "    BEGIN\n"
#~ "        SELECT accessed_at INTO v_accessed_at FROM users WHERE username = "
#~ "p_uname;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"

#~ msgid ""
#~ "    String name = //user input\n"
#~ "    int age = //user input\n"
#~ "    Session session = //...\n"
#~ "    Query query = session.createQuery(\"from People where lastName = :"
#~ "name and age > :age\");\n"
#~ "    query.setString(\"name\", name);\n"
#~ "    query.setInteger(\"age\", age);\n"
#~ "    Iterator people = query.iterate();"
#~ msgstr ""
#~ "    String name = //Benutzereingabe\n"
#~ "    int age = //Benutzereingabe\n"
#~ "    Session session = //...\n"
#~ "    Query query = session.createQuery(\"from People where lastName = :"
#~ "name and age > :age\");\n"
#~ "    query.setString(\"name\", name);\n"
#~ "    query.setInteger(\"age\", age);\n"
#~ "    Iterator people = query.iterate();"

#~ msgid ""
#~ "    JANIHUR LAST SEEN\n"
#~ "    -------------------\n"
#~ "    2011-08-03 17:11:24"
#~ msgstr ""
#~ "    JANIHUR LAST SEEN\n"
#~ "    -------------------\n"
#~ "    2011-08-03 17:11:24"

#~ msgid "The MySQL Improved extension handles bound parameters."
#~ msgstr "Die Erweiterung MySQL Improved beherrscht Parameterbindung."

#~ msgid ""
#~ "    SUPERUSER LAST SEEN\n"
#~ "    -------------------"
#~ msgstr ""
#~ "    SUPERUSER LAST SEEN\n"
#~ "    -------------------"

#~ msgid ""
#~ "-   Add some narrative\n"
#~ "-   Show code examples\n"
#~ msgstr ""
#~ "-   Mehr Erläuterung\n"
#~ "-   Codebeispiele zeigen\n"

#~ msgid "String concatenation opens doors to possible SQL injection exploits:"
#~ msgstr "Durch Stringverknüpfung kann es zu SQL-Einschleusung kommen:"

#~ msgid ""
#~ "That's it. Don't try to escape invalid characters. Don't try to do it "
#~ "yourself. Learn how to use parameterized statements. Always, every single "
#~ "time."
#~ msgstr ""
#~ "Das ist alles. Nicht versuchen, ungültige Zeichen zu maskieren. Nicht "
#~ "versuchen, es eigenhändig zu machen. Lerne, parameterisierte Anweisungen "
#~ "zu benutzen, und zwar immer und jedes Mal."

#~ msgid ""
#~ "    SUPERUSER LAST SEEN\n"
#~ "    -------------------\n"
#~ "    2011-07-22 17:11:24"
#~ msgstr ""
#~ "    SUPERUSER LAST SEEN\n"
#~ "    -------------------\n"
#~ "    2011-07-22 17:11:24"

#~ msgid ""
#~ "[MyBatis](http://www.mybatis.org/) is a database framework that\n"
#~ "hides a lot of the JDBC code from the developer, allowing him or\n"
#~ "her to focus on writing SQL.  The SQL statements are typically\n"
#~ "stored in XML files."
#~ msgstr ""
#~ "[MyBatis](http://www.mybatis.org/) ist ein Datenbankframework,\n"
#~ "das viel von dem JDBC-Code vor dem Entwickler versteckt, so dass er\n"
#~ "oder sie sich darauf konzentrieren kann, SQL zu schreiben. Die\n"
#~ "SQL-Anweisungen werden typischerweise in XML-Dateien gespeichert."

#~ msgid ""
#~ "\n"
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT accessed_at FROM users WHERE username = :a';\n"
#~ "    BEGIN\n"
#~ "        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"
#~ msgstr ""
#~ "\n"
#~ "    CREATE OR REPLACE FUNCTION user_access (\n"
#~ "        p_uname IN VARCHAR2\n"
#~ "    ) RETURN date AS\n"
#~ "        v_accessed_at date;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT accessed_at FROM users WHERE username = :a';\n"
#~ "    BEGIN\n"
#~ "        EXECUTE IMMEDIATE v_query INTO v_accessed_at USING p_uname;\n"
#~ "        RETURN v_accessed_at;\n"
#~ "    END;\n"
#~ "    /"

#~ msgid ""
#~ "See the\n"
#~ "[Hibernate Manual](http://docs.jboss.org/hibernate/stable/core/reference/"
#~ "en/html/objectstate.html#objectstate-querying-executing-parameters)\n"
#~ "for more information on named parameters."
#~ msgstr ""
#~ "Siehe das [Handbuch zu Hibernate](http://docs.jboss.org/hibernate/stable/"
#~ "core/reference/en/html/objectstate.html#objectstate-querying-executing-"
#~ "parameters) zu weitere Informationen über benannte Parameter."

#~ msgid ""
#~ "Also NLS session parameters (`NLS_DATE_FORMAT`, `NLS_TIMESTAMP_FORMAT`, "
#~ "`NLS_TIMESTAMP_TZ_FORMAT`, `NLS_NUMERIC_CHARACTER`) can be used to modify "
#~ "or inject SQL statements."
#~ msgstr ""
#~ "Auch die NLS-Sitzungsparameter (`NLS_DATE_FORMAT`, "
#~ "`NLS_TIMESTAMP_FORMAT`, `NLS_TIMESTAMP_TZ_FORMAT`, "
#~ "`NLS_NUMERIC_CHARACTER`) können benutzt werden, um SQL-Abfragen zu "
#~ "verändern oder in sie einzuschleusen."

#~ msgid ""
#~ "Examples\n"
#~ "========"
#~ msgstr ""
#~ "Beispiele\n"
#~ "========="

#~ msgid "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"
#~ msgstr "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';"

#~ msgid ""
#~ "To give you some context, here's an example showing how a basic\n"
#~ "query is called with MyBatis.  The input data is passed into the\n"
#~ "`PeopleMapper` instance and then it gets inserted into the\n"
#~ "\"selectPeopleByNameAndAge\" query."
#~ msgstr ""
#~ "Um etwas Kontext zu herzustellen, so sieht ein Beispiel aus\n"
#~ "wie eine einfache Abfrage mit MyBatis aufgerufen wird. Die\n"
#~ "Eingabedaten werden der Instanz `PeopleMapper` übergeben und\n"
#~ "dann in die Abfrage \"selectPeopleByNameAndAge\" eingefügt."

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION users_since(\n"
#~ "        p_since IN DATE\n"
#~ "    ) RETURN userlist_t PIPELINED AS\n"
#~ "        v_users userlist_t;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT username FROM users WHERE superuser = 0 and accessed_at "
#~ "> ''' || p_since || ''' order by accessed_at desc';\n"
#~ "    BEGIN\n"
#~ "        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
#~ "        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION users_since(\n"
#~ "        p_since IN DATE\n"
#~ "    ) RETURN userlist_t PIPELINED AS\n"
#~ "        v_users userlist_t;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT username FROM users WHERE superuser = 0 and accessed_at "
#~ "> ''' || p_since || ''' order by accessed_at desc';\n"
#~ "    BEGIN\n"
#~ "        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
#~ "        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#~ msgid ""
#~ "    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
#~ "    <!DOCTYPE mapper\n"
#~ "    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
#~ "    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
#~ "    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
#~ "    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
#~ "        <!-- lastName and age are automatically sanitized --->\n"
#~ "        SELECT * FROM people WHERE lastName = #{lastName} AND age > #"
#~ "{age}\n"
#~ "    </select>\n"
#~ "    </mapper>"
#~ msgstr ""
#~ "    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
#~ "    <!DOCTYPE mapper\n"
#~ "    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n"
#~ "    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n"
#~ "    <mapper namespace=\"com.bobbytables.mybatis.PeopleMapper\">\n"
#~ "    <select id=\"selectPeopleByNameAndAge\" resultType=\"list\">\n"
#~ "        <!-- lastName und age werden automatisch bereinigt --->\n"
#~ "        SELECT * FROM people WHERE lastName = #{lastName} AND age > #"
#~ "{age}\n"
#~ "    </select>\n"
#~ "    </mapper>"

#~ msgid ""
#~ "        RETURN;\n"
#~ "    END;\n"
#~ "    /"
#~ msgstr ""
#~ "        RETURN;\n"
#~ "    END;\n"
#~ "    /"

#~ msgid ""
#~ "    String name = //user input\n"
#~ "    int age = //user input\n"
#~ "    Connection connection = DriverManager.getConnection(...);\n"
#~ "    PreparedStatement statement = connection.prepareStatement(\n"
#~ "            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
#~ "    statement.setString(1, name); //lastName is a VARCHAR\n"
#~ "    statement.setInt(2, age); //age is an INT\n"
#~ "    ResultSet rs = statement.executeQuery();\n"
#~ "    while (rs.next()){\n"
#~ "        //...\n"
#~ "    }"
#~ msgstr ""
#~ "    String name = //Benutzereingabe\n"
#~ "    int age = //Benutzereingabe\n"
#~ "    Connection connection = DriverManager.getConnection(...);\n"
#~ "    PreparedStatement statement = connection.prepareStatement(\n"
#~ "            \"SELECT * FROM people WHERE lastName = ? AND age > ?\" );\n"
#~ "    statement.setString(1, name); //lastName is a VARCHAR\n"
#~ "    statement.setInt(2, age); //age is an INT\n"
#~ "    ResultSet rs = statement.executeQuery();\n"
#~ "    while (rs.next()){\n"
#~ "        //...\n"
#~ "    }"

#~ msgid ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at >\n"
#~ "    '2011-07-04SUPRISE!' order by accessed_at desc"
#~ msgstr ""
#~ "    v_query = SELECT username FROM users WHERE superuser = 0 and "
#~ "accessed_at >\n"
#~ "    '2011-07-04SUPRISE!' order by accessed_at desc"

#~ msgid ""
#~ "To do\n"
#~ "-----"
#~ msgstr ""
#~ "In Vorbereitung\n"
#~ "---------------"

#~ msgid ""
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or "
#~ "username = ''whocares\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since"
#~ "(sysdate - 30));"
#~ msgstr ""
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = '\"'' or superuser = 1 or "
#~ "username = ''whocares\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"SUPERUSER IS\" FROM TABLE(users_since"
#~ "(sysdate - 30));"

#~ msgid ""
#~ "\n"
#~ "    String username = \"joe.bloggs\";\n"
#~ "    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
#~ "last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
#~ "    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"
#~ msgstr ""
#~ "\n"
#~ "    String username = \"joe.bloggs\";\n"
#~ "    SqlCommand sqlQuery = new SqlCommand(\"SELECT user_id, first_name,"
#~ "last_name FROM users WHERE username = ?username\",  sqlConnection);\n"
#~ "    sqlQuery.Parameters.AddWithValue(\"?username\", username);\n"

#~ msgid ""
#~ "    SUPERUSE\n"
#~ "    --------\n"
#~ "    petdance"
#~ msgstr ""
#~ "    SUPERUSE\n"
#~ "    --------\n"
#~ "    petdance"

#~ msgid ""
#~ "    String name = //user input\n"
#~ "    int age = //user input\n"
#~ "    SqlSessionFactory sqlMapper = //...\n"
#~ "    SqlSession session = sqlMapper.openSession();\n"
#~ "    try {\n"
#~ "        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
#~ "        List<Person> people = mapper.selectPeopleByNameAndAge(name, "
#~ "age); //data is automatically sanitized\n"
#~ "        for (Person person : people) {\n"
#~ "            //...\n"
#~ "        }\n"
#~ "    } finally {\n"
#~ "        session.close();\n"
#~ "    }\n"
#~ msgstr ""
#~ "    String name = //Benutzereingabe\n"
#~ "    int age = //Benutzereingabe\n"
#~ "    SqlSessionFactory sqlMapper = //...\n"
#~ "    SqlSession session = sqlMapper.openSession();\n"
#~ "    try {\n"
#~ "        PeopleMapper mapper = session.getMapper(PeopleMapper.class);\n"
#~ "        List<Person> people = mapper.selectPeopleByNameAndAge(name, "
#~ "age); //data is automatically sanitized\n"
#~ "        for (Person person : people) {\n"
#~ "            //...\n"
#~ "        }\n"
#~ "    } finally {\n"
#~ "        session.close();\n"
#~ "    }\n"

#~ msgid ""
#~ "    CREATE OR REPLACE FUNCTION users_since(\n"
#~ "        p_since IN DATE\n"
#~ "    ) RETURN userlist_t PIPELINED AS\n"
#~ "        v_users userlist_t;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT username FROM users WHERE superuser = 0 and accessed_at "
#~ "> ''' || to_char(p_since, 'YYYY-MM-DD') || ''' order by accessed_at "
#~ "desc';\n"
#~ "    BEGIN\n"
#~ "        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
#~ "        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"
#~ msgstr ""
#~ "    CREATE OR REPLACE FUNCTION users_since(\n"
#~ "        p_since IN DATE\n"
#~ "    ) RETURN userlist_t PIPELINED AS\n"
#~ "        v_users userlist_t;\n"
#~ "        v_query constant varchar2(32767) := \n"
#~ "          'SELECT username FROM users WHERE superuser = 0 and accessed_at "
#~ "> ''' || p_since || ''' order by accessed_at desc';\n"
#~ "    BEGIN\n"
#~ "        DBMS_OUTPUT.PUT_LINE('v_query = ' || v_query);\n"
#~ "        EXECUTE IMMEDIATE v_query BULK COLLECT INTO v_users;"

#~ msgid "[From the webcomic _xkcd_](http://xkcd.com/327/)"
#~ msgstr "[Vom Webcomic _xkcd_](http://xkcd.com/327/)"

#~ msgid ""
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
#~ "30));"
#~ msgstr ""
#~ "    ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD\"SUPRISE!\"';\n"
#~ "    SELECT COLUMN_VALUE AS \"REGULARS\" FROM TABLE(users_since(sysdate - "
#~ "30));"

#~ msgid ""
#~ "Patches welcome\n"
#~ "==============="
#~ msgstr ""
#~ "Verbesserungen sind willkommen\n"
#~ "=============================="

#~ msgid ""
#~ "    REGULARS\n"
#~ "    --------\n"
#~ "    janihur\n"
#~ "    albundy\n"
#~ "    donduck\n"
#~ msgstr ""
#~ "    REGULARS\n"
#~ "    --------\n"
#~ "    janihur\n"
#~ "    albundy\n"
#~ "    donduck\n"

#~ msgid ""
#~ "Perl's [DBI](http://search.cpan.org/dist/DBI), available on the [CPAN]"
#~ "(http://search.cpan.org), supports parameterized SQL calls.  Both the "
#~ "`do` method and `prepare` method support parameters (\"placeholders\", as "
#~ "they call them) for most database drivers. For example:"
#~ msgstr ""
#~ "Die Perl-Datenbankschnittstelle [DBI](http://search.cpan.org/dist/DBI), "
#~ "erhältlich vom [CPAN](http://search.cpan.org), beherrscht "
#~ "parameterisierte SQL-Aufrufe. Die Methoden `do` und `prepare` "
#~ "unterstützen Parameter (dort: \"Platzhalter\") für die meisten "
#~ "Datenbanktreiber. Zum Beispiel:"

#~ msgid ""
#~ "All of PostgreSQL's [procedural languages](http://www.postgresql.org/docs/"
#~ "current/static/xplang.html), which allow you to write functions and "
#~ "procedures inside the database, allow you to execute arbitrary SQL "
#~ "statements."
#~ msgstr ""
#~ "Alle [prozeduralen Sprachen von PostgreSQL](http://www.postgresql.org/"
#~ "docs/current/static/xplang.html), mit denen man Funktionen und Prozeduren "
#~ "innerhalb der Datenbank schreiben kann, haben die Fähigkeit, beliebige "
#~ "SQL-Anweisungen auszuführen."

#~ msgid ""
#~ "However, you can't use parameterization for identifiers (table\n"
#~ "names, column names) so you need to use DBI's `quote_identifier()`\n"
#~ "method for that:"
#~ msgstr ""
#~ "Man kann aber Parameterisierung nicht für Benenner (Tabellennamen, "
#~ "Spaltennamen) verwenden, also muss man die Methode `quote_identifier()` "
#~ "aus DBI verwenden:"

#~ msgid ""
#~ "The safest way to execute SQL inside a PL/pgSQL statement is just to do "
#~ "so:"
#~ msgstr ""
#~ "Die sicherste Weise, SQL innerhalb einer PL/pgSQL-Anweisung auszuführen:"

#~ msgid ""
#~ ".NET\n"
#~ "===="
#~ msgstr ""
#~ ".NET\n"
#~ "===="

#~ msgid ""
#~ "For such a simple case, you're actually better off writing a pure SQL "
#~ "function:"
#~ msgstr ""
#~ "In so einem einfachen Fall schreibt man besser eine reine SQL-Funktion:"

#~ msgid "<br clear=\"right\">"
#~ msgstr "<br clear=\"right\">"

#~ msgid ""
#~ "But sometimes you have to do more complicated things. Perhaps you "
#~ "dynamically add `WHERE` clause expressions based on input. In such cases, "
#~ "you'll end up using PL/pgSQL's `EXECUTE` syntax. Here's an example with "
#~ "an SQL injection vulnerability:"
#~ msgstr ""
#~ "Aber manchmal möchte man kompliziertere Sachen machen wie z.B. `WHERE`-"
#~ "Teilausdrücke dynamisch je nach Eingabedaten hinzuzufügen. In diesem Fall "
#~ "benutzt man die `EXECUTE`-Syntax von PL/pgSQL. Ein Beispiel mit einer "
#~ "Gefährdung durch SQL-Einschleusung:"

#~ msgid ""
#~ "* Fork the [bobby-tables repository at github](http://github.com/petdance/"
#~ "bobby-tables), make your changes, and send me a pull request.\n"
#~ "* Add an issue in the [issue tracker](http://github.com/petdance/bobby-"
#~ "tables/issues).\n"
#~ "* Email me, Andy Lester, at andy at petdance.com."
#~ msgstr ""
#~ "* Erstelle einen Fork vom [Repository bobby-tables auf github](http://"
#~ "github.com/petdance/bobby-tables), füge die Änderungen hinzu und schicke "
#~ "mir einen Pull-Request.\n"
#~ "* Erstelle eine Anfrage im [Fallbearbeitungssystem](http://github.com/"
#~ "petdance/bobby-tables/issues).\n"
#~ "* Schicke mir eine Email: Andy Lester, andy at petdance.com."

#~ msgid ""
#~ "Both the `p_column` and the `p_value` arguments are vulnerable. The way "
#~ "to avoid this problem is to use the `quote_ident()` function to quote an "
#~ "SQL identifier (`p_column` in this case) and `quote_lteral()` to quote a "
#~ "literal value:"
#~ msgstr ""
#~ "Die Argumente `p_column` und `p_value` sind beide angreifbar. Um das "
#~ "Problem zu vermeiden, wird die Funktion `quote_ident()` verwendet, um "
#~ "einen SQL-Bezeichner (hier: `p_column`) zu maskieren und `quote_literal()"
#~ "`, um einen Literalwert zu maskieren:"

#~ msgid ""
#~ "You could also avoid writing SQL by hand by using [DBIx::Class](http://"
#~ "p3rl.org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::Abstract) etc "
#~ "to generate your SQL for you programmatically."
#~ msgstr ""
#~ "Man kann auch vermeiden, SQL manuell zu schreiben, indem man [DBIx::Class]"
#~ "(http://p3rl.org/DBIx::Class), [SQL::Abstract](http://p3rl.org/SQL::"
#~ "Abstract) usw. verwendet, um SQL programmatisch zu erzeugen."

#~ msgid "It's quite a bit easier to read, too!"
#~ msgstr "So ist es auch viel leichter zu lesen!"

#~ msgid ""
#~ "    # Assume @cols contains a list of column names you need to fetch:\n"
#~ "    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"
#~ msgstr ""
#~ "    # Unter der Annahme, dass @cols eine Liste der zu holenden "
#~ "Spaltennamen enthält:\n"
#~ "    my $cols = join ',', map { $dbh->quote_identifier($_) } @cols;"

#~ msgid "TODO."
#~ msgstr "In Vorbereitung."

#~ msgid ""
#~ "Help translate this site! There are less than 200 phrases. No programming "
#~ "necessary."
#~ msgstr ""
#~ "Hilf mit, diesen Webauftritt zu übersetzen! Es sind weniger als 200 "
#~ "Ausdrücke. Keine Programmierung notwendig."

#~ msgid "### PL/Tcl"
#~ msgstr "### PL/Tcl"

#~ msgid ""
#~ "Taint mode is a special set of security checks that Perl performs on data "
#~ "input into your program from external sources. The input data is marked "
#~ "as  tainted (untrusted) and may not be used in commands that would allow "
#~ "you to shoot yourself in the foot. See [the perlsec manpage](http://"
#~ "perldoc.perl.org/perlsec.html) for a detailed breakdown of what taint "
#~ "mode tracks."
#~ msgstr ""
#~ "Der Taintmodus stellt besondere Sicherheitsprüfungen dar, die Perl an "
#~ "Eingabedaten durchführt, welche aus externen Quellen stammen. Die "
#~ "Eingabedaten werden als \"unrein\" (nicht vertrauenswürdig) markiert und "
#~ "können nicht in Befehlen verwendet werden, mit denen man sich ins eigene "
#~ "Fleisch schneiden würde. Siehe [perlsec](http://perldoc.perl.org/perlsec."
#~ "html) für eine detaillierte Übersicht, was der Taintmodus überwacht."

#~ msgid ""
#~ "Python\n"
#~ "======"
#~ msgstr ""
#~ "Python\n"
#~ "======"

#~ msgid ""
#~ "    # From the command line\n"
#~ "    perl -T program.pl"
#~ msgstr ""
#~ "    # Auf der Kommandozeile\n"
#~ "    perl -T program.pl"

#~ msgid ""
#~ "    # Do NOT do it this way.\n"
#~ "    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
#~ "    curs.execute(cmd)"
#~ msgstr ""
#~ "    # Dieses Beispiel ist FALSCH.\n"
#~ "    cmd = \"update people set name='%s' where id='%s'\" % (name, id)\n"
#~ "    curs.execute(cmd)"

#~ msgid ""
#~ "    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', array"
#~ "($email));\n"
#~ "    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
#~ "    $sth->execute(array(':email' => $email));"
#~ msgstr ""
#~ "    $res = odbc_exec($conn, 'SELECT * FROM users WHERE email = ?', array"
#~ "($email));\n"
#~ "    $sth = $dbh->prepare('SELECT * FROM users WHERE email = :email');\n"
#~ "    $sth->execute(array(':email' => $email));"

#~ msgid ""
#~ "    curs.execute('update people set name=:1 where id=:2', [name, id])"
#~ msgstr ""
#~ "    curs.execute('update people set name=:1 where id=:2', [name, id])"

#~ msgid ""
#~ "-    [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system."
#~ "data.sqlclient.sqlcommand.prepare.aspx) in the .NET Framework Class "
#~ "Library"
#~ msgstr ""
#~ "-   [SqlCommand.Prepare](http://msdn.microsoft.com/en-us/library/system."
#~ "data.sqlclient.sqlcommand.prepare.aspx) in der Klassenbibliothek des .NET-"
#~ "Framework"

#~ msgid ""
#~ "Ruby\n"
#~ "===="
#~ msgstr ""
#~ "Ruby\n"
#~ "===="

#~ msgid "**Mom**: Oh, dear -- Did he break something?"
#~ msgstr "**Mutter**: Auweia – hat er etwas kaputtgemacht?"

#~ msgid ""
#~ "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"
#~ msgstr ""
#~ "    Person.find :all, :conditions => ['id = ? or name = ?', id, name]"

#~ msgid "-   Add some narrative.\n"
#~ msgstr "-   Mehr Erläuterung.\n"

#~ msgid ""
#~ "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"
#~ msgstr ""
#~ "    Person.find_by_sql ['SELECT * from persons WHERE name = ?', name]"

#~ msgid ""
#~ "To do\n"
#~ "====="
#~ msgstr ""
#~ "In Vorbereitung\n"
#~ "==============="

#~ msgid ""
#~ "Scheme\n"
#~ "======"
#~ msgstr ""
#~ "Scheme\n"
#~ "======"

#~ msgid ""
#~ "\n"
#~ "    <cfscript>\n"
#~ "      var myQuery = new Query(sql=\"\n"
#~ "        SELECT FirstName, LastName, Phone\n"
#~ "        FROM   tblUser\n"
#~ "        WHERE  Status = :status\n"
#~ "      \");\n"
#~ "      myQuery.addParam(\n"
#~ "        name      = \"status\",\n"
#~ "        value     = form.status,\n"
#~ "        cfsqltype = \"cf_sql_varchar\"\n"
#~ "      );\n"
#~ "      var rawQuery = myQuery.execute().getResult();\n"
#~ "    </cfscript>"
#~ msgstr ""
#~ "\n"
#~ "    <cfscript>\n"
#~ "      var myQuery = new Query(sql=\"\n"
#~ "        SELECT FirstName, LastName, Phone\n"
#~ "        FROM   tblUser\n"
#~ "        WHERE  Status = :status\n"
#~ "      \");\n"
#~ "      myQuery.addParam(\n"
#~ "        name      = \"status\",\n"
#~ "        value     = form.status,\n"
#~ "        cfsqltype = \"cf_sql_varchar\"\n"
#~ "      );\n"
#~ "      var rawQuery = myQuery.execute().getResult();\n"
#~ "    </cfscript>"

#~ msgid ""
#~ "[CHICKEN](http://www.call-with-current-continuation.org/) is a compiler "
#~ "for [Scheme](http://schemers.org/)"
#~ msgstr ""
#~ "[CHICKEN](http://www.call-with-current-continuation.org/) ist ein "
#~ "Compiler für [Scheme](http://schemers.org/)"

#~ msgid ""
#~ "ASP\n"
#~ "==="
#~ msgstr ""
#~ "ASP\n"
#~ "==="

#~ msgid ""
#~ "This site's content is available under the <a href=\"https://"
#~ "creativecommons.org/licenses/by-sa/3.0/\">Creative Commons Attribution-"
#~ "ShareAlike 3.0 License</a>"
#~ msgstr ""
#~ "Die Inhalte dieser Website stehen unter der <a href=\"http://"
#~ "creativecommons.org/licenses/by-sa/3.0/\">Creative-Commons-Lizenz mit "
#~ "Namensnennung und Weitergabe unter gleichen Bedingungen, Version 3.0</a>."

#~ msgid "Instead, do this:"
#~ msgstr "Stattdessen korrekt:"

#~ msgid "Bobby Tables: A guide to preventing SQL injection"
#~ msgstr "Bobby Tables: Ein Leitfaden gegen SQL-Einschleusung"

#~ msgid ""
#~ "**However**, you should probably be using an abstraction layer.\n"
#~ "The [ODBC](http://php.net/manual/en/book.uodbc.php) and\n"
#~ "[PDO](http://www.php.net/manual/en/book.pdo.php) extensions both\n"
#~ "support parameterization and multiple databases:"
#~ msgstr ""
#~ "Es sollte jedoch wohl eine Abstraktionsschicht verwendet werden.\n"
#~ "Die [ODBC-](http://php.net/manual/en/book.uodbc.php) und\n"
#~ "[PDO-Erweiterungen](http://www.php.net/manual/en/book.pdo.php)\n"
#~ "unterstützen sowohl Parameterisierung und mehrere Datenbanken:"

#~ msgid "bobby-tables.com: A guide to preventing SQL injection in {currlang}"
#~ msgstr ""
#~ "bobby-tables.com: Ein Leitfaden gegen SQL-Einschleusung in {currlang}"
